{
  "root": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter",
  "generatedAt": "2026-02-15T22:24:33.491Z",
  "all": [
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\app\\forum\\Forum.jsx",
      "issues": [
        {
          "startLine": 11005,
          "endLine": 11076,
          "block": "  React.useEffect(() => {\n    if (!active || typeof window === 'undefined') return;\n\n    const { body, documentElement } = document;\n\n    // В форуме основной скролл живёт во внутреннем контейнере .body (overflowY:auto).\n    // Если он есть — лочим именно его, чтобы после закрытия оверлея НЕ прыгать в самый верх.\n    const scrollEl =\n      document.querySelector('[data-forum-scroll=\"1\"]') ||\n      document.querySelector('.forum_root .grid2 > section > .body') ||\n      null;\n\n    const winY = window.scrollY || window.pageYOffset || 0;\n    const innerY = scrollEl ? (scrollEl.scrollTop || 0) : 0;\n\n    const useInner =\n      !!scrollEl &&\n      scrollEl !== body &&\n      (scrollEl.scrollHeight - scrollEl.clientHeight) > 2;\n\n    const prev = {\n      bodyOverflow: body.style.overflow,\n      bodyPosition: body.style.position,\n      bodyTop: body.style.top,\n      bodyWidth: body.style.width,\n      htmlOverscroll: documentElement.style.overscrollBehaviorY,\n      innerOverflow: useInner ? scrollEl.style.overflow : null,\n      innerOverscroll: useInner ? scrollEl.style.overscrollBehaviorY : null,\n    };\n\n    if (useInner) {\n      // Лочим внутренний скролл-контейнер без body:fixed (иначе возможны прыжки).\n      body.style.overflow = 'hidden';\n      documentElement.style.overscrollBehaviorY = 'none';\n      scrollEl.style.overflow = 'hidden';\n      scrollEl.style.overscrollBehaviorY = 'none';\n    } else {\n      // Фолбэк: обычная страница со скроллом окна.\n      body.style.position = 'fixed';\n      body.style.top = `-${winY}px`;\n      body.style.width = '100%';\n      body.style.overflow = 'hidden';\n      documentElement.style.overscrollBehaviorY = 'none';\n    }\n\n    const prevent = (e) => e.preventDefault();\n    window.addEventListener('wheel', prevent, { passive: false });\n    window.addEventListener('touchmove', prevent, { passive: false });\n\n    return () => {\n      window.removeEventListener('wheel', prevent);\n      window.removeEventListener('touchmove', prevent);\n\n      body.style.overflow = prev.bodyOverflow;\n      body.style.position = prev.bodyPosition;\n      body.style.top = prev.bodyTop;\n      body.style.width = prev.bodyWidth;\n      documentElement.style.overscrollBehaviorY = prev.htmlOverscroll;\n\n      if (useInner && scrollEl) {\n        scrollEl.style.overflow = prev.innerOverflow || '';\n        scrollEl.style.overscrollBehaviorY = prev.innerOverscroll || '';\n        requestAnimationFrame(() => {\n          try { scrollEl.scrollTop = innerY; } catch {}\n        });\n      } else {\n        requestAnimationFrame(() => {\n          try { window.scrollTo(0, winY); } catch {}\n        });\n      }\n    };\n  }, [active]);",
          "add": 2,
          "rem": 2,
          "si": 0,
          "ci": 0,
          "raf": 2,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(2) > cancelAnimationFrame(0)"
          ]
        },
        {
          "startLine": 13252,
          "endLine": 13300,
          "block": "React.useEffect(() => {\n  const onEdit = (e) => {\n    try {\n      const d = e?.detail || {};\n      if (!d?.postId || typeof d?.text !== 'string') return;\n\n      // какой пост правим + текст в композер\n      setEditPostId(String(d.postId));\n      setText(String(d.text));\n\n      // сразу открыть композер\n      try {\n        setComposerActive(true);\n      } catch {}\n\n      // после рендера — проскроллить и фокуснуть поле\n      try {\n        requestAnimationFrame(() => {\n          const root =\n            (composerRef && composerRef.current) ||\n            document.getElementById('forum-composer');\n\n          if (root && root.scrollIntoView) {\n            root.scrollIntoView({ behavior: 'smooth', block: 'center' });\n          }\n\n          // ищем textarea: либо по классу .taInput, либо любую textarea внутри\n          const ta =\n            root?.querySelector?.('.taInput') ||\n            root?.querySelector?.('textarea');\n\n          if (ta && typeof ta.focus === 'function') {\n            ta.focus();\n          }\n        });\n      } catch {}\n\n      // тост про режим редактирования\n      try {\n        toast?.ok?.(t?.('forum_edit_mode'));\n      } catch {}\n    } catch {}\n  };\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('forum:edit', onEdit);\n    return () => window.removeEventListener('forum:edit', onEdit);\n  }\n}, [t, toast]); // ВАЖНО: без setComposerActive и composerRef",
          "add": 1,
          "rem": 1,
          "si": 0,
          "ci": 0,
          "raf": 1,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(1) > cancelAnimationFrame(0)"
          ]
        },
        {
          "startLine": 14428,
          "endLine": 14479,
          "block": "useEffect(() => {\n  if (!isBrowser()) return;\n\n  const cur = sel?.id ? String(sel.id) : null;\n  const prev = prevSelIdRef.current;\n  prevSelIdRef.current = cur;\n  if (!cur) return;\n\n  // если тема реально \"вошла\" (а не просто ре-рендер)\n  const entered = cur !== prev;\n\n  // Если сейчас идём по deep-link/открытию ветки конкретного поста — не перетираем скролл в начало\n  const hasPendingTarget =\n    !!pendingScrollToPostIdRef.current ||\n    !!pendingThreadRootIdRef.current;\n\n  // шапку — спрятать всегда при входе в тему (по твоему ТЗ)\n  try { headAutoOpenRef.current = false; } catch {}\n  try { setHeadPinned(false); } catch {}\n  try { setHeadHidden(true); } catch {}\n\n  if (!entered) return;\n  if (hasPendingTarget) return;\n\n  const scrollToThreadStart = () => {\n    try {\n      const scrollEl =\n        bodyRef.current ||\n        document.querySelector('[data-forum-scroll=\"1\"]') ||\n        null;\n\n      // 1) сначала грубо в 0 (как \"Домой\")\n      if (scrollEl && scrollEl.scrollHeight > scrollEl.clientHeight + 1) {\n        scrollEl.scrollTop = 0;\n      } else {\n        window.scrollTo(0, 0);\n      }\n\n      // 2) затем точно якорем (чтобы первый элемент встал под верхнюю грань)\n      document\n        .querySelector('[data-forum-thread-start=\"1\"]')\n        ?.scrollIntoView({ behavior: 'auto', block: 'start' });\n    } catch {}\n  };\n\n  // двойной RAF: ждём применения collapsed-шапки + layout\n  try {\n    requestAnimationFrame(() => requestAnimationFrame(scrollToThreadStart));\n  } catch {\n    setTimeout(scrollToThreadStart, 0);\n  }\n}, [sel?.id]);",
          "add": 0,
          "rem": 0,
          "si": 0,
          "ci": 0,
          "raf": 2,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(2) > cancelAnimationFrame(0)",
            "⚠ нет cleanup return(), но есть подписки/таймеры"
          ]
        },
        {
          "startLine": 14481,
          "endLine": 14637,
          "block": "useEffect(() => {\n  if (!isBrowser()) return;\n\n  // === HEAD AUTO OPEN/CLOSE: пороги + гистерезис + анти-дергание scrollTop ===\n  // CSS-переменные (px):\n  //  --head-open-threshold-desktop: 870px;\n  //  --head-close-threshold-desktop: 920px;  // обычно open + 40..120\n  //  --head-open-threshold-mobile: 550px;\n  //  --head-close-threshold-mobile: 610px;   // обычно open + 40..120\n  //\n  // Плюс: --head-collapse-scroll-compensate: 1;  (0/1) — компенсировать скролл при скрытии шапки\n\n  const DEFAULT_HEAD_OPEN_DESKTOP = 870;\n  const DEFAULT_HEAD_CLOSE_DESKTOP = 920;\n  const DEFAULT_HEAD_OPEN_MOBILE = 550;\n  const DEFAULT_HEAD_CLOSE_MOBILE = 610;\n\n  const isMobileUi = () => {\n    try {\n      const coarse = !!window?.matchMedia?.('(pointer: coarse)')?.matches;\n      const narrow = (Number(window?.innerWidth || 0) || 0) <= 720;\n      return coarse || narrow;   \n     } catch {}\n    return false;\n  };\n\n  const readCssPx = (varName, fallback) => {\n    try {\n      const raw = window.getComputedStyle(document.documentElement).getPropertyValue(varName);\n      const v = String(raw || '').trim();\n      const n = parseFloat(v);\n      return Number.isFinite(n) ? n : fallback;\n    } catch {}\n    return fallback;\n  };\n\n  const readCssFlag01 = (varName, fallback01) => {\n    try {\n      const raw = window.getComputedStyle(document.documentElement).getPropertyValue(varName);\n      const v = String(raw || '').trim();\n      if (v === '0') return 0;\n      if (v === '1') return 1;\n      const n = parseFloat(v);\n      return Number.isFinite(n) ? (n ? 1 : 0) : fallback01;\n    } catch {}\n    return fallback01;\n  };\n\n  const getHeadOpenAt = () => {\n    const m = isMobileUi();\n    return readCssPx(m ? '--head-open-threshold-mobile' : '--head-open-threshold-desktop',\n      m ? DEFAULT_HEAD_OPEN_MOBILE : DEFAULT_HEAD_OPEN_DESKTOP\n    );\n  };\n\n  const getHeadCloseAt = (openAt) => {\n    const m = isMobileUi();\n    const closeAt = readCssPx(m ? '--head-close-threshold-mobile' : '--head-close-threshold-desktop',\n      m ? DEFAULT_HEAD_CLOSE_MOBILE : DEFAULT_HEAD_CLOSE_DESKTOP\n    );\n    // гарантируем гистерезис: close > open хотя бы на 1px\n    return Math.max((Number(openAt) || 0) + 1, Number(closeAt) || 0);\n  };\n\n  const getHeadHeight = () => {\n    try {\n      // headInner — реальная шапка внутри контейнера .head\n      const el = document.querySelector('.headInner') || document.querySelector('.head');\n      const h = el?.getBoundingClientRect?.()?.height;\n      return Number.isFinite(h) ? h : 0;\n    } catch {}\n    return 0;\n  };\n\n  const getScrollTop = () => {\n    const el = bodyRef.current;\n    if (el && el.scrollHeight > el.clientHeight + 1) return el.scrollTop || 0;\n    return (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);\n  };\n\n  let raf = 0;\n  let lastTop = getScrollTop();\n  const onScroll = () => {\n    if (navRestoringRef.current) return;\n    if (raf) return;\n    raf = window.requestAnimationFrame(() => {\n      raf = 0;\n      const st = getScrollTop();\n      const delta = st - lastTop;\n      const scrollingDown = delta > 0;\n      const openAt = getHeadOpenAt();\n      const closeAt = getHeadCloseAt(openAt);\n      const atTopForOpen = st <= openAt;\n\n      // если шапка закреплена вручную — ничего не трогаем\n      if (headPinnedRef.current) {\n        headAutoOpenRef.current = false;\n        lastTop = st;\n        return;\n      }\n\n      // Как только упираемся в верх — сразу открываем шапку\n      if (!videoFeedOpenRef.current && atTopForOpen) {\n        if (headHiddenRef.current) {\n          setHeadPinned(false);\n          setHeadHidden(false);\n        }\n        headAutoOpenRef.current = false;\n      } else if (!headHiddenRef.current && scrollingDown && st > closeAt) {\n        // Скрываем только ниже closeAt (гистерезис), чтобы не дергалось на пороге.\n        // И компенсируем скролл, чтобы при скрытии шапки scrollTop не \"клампился\" в 0.\n        const prevSt = st;\n        const headH = getHeadHeight();\n        const compensate = readCssFlag01('--head-collapse-scroll-compensate', 1);\n        setHeadPinned(false);\n        setHeadHidden(true);\n\n        if (compensate && headH > 1) {\n          // Двойной RAF — ждём, пока DOM применит collapsed-класс и пересчитает layout.\n          const applyComp = () => {\n            try {\n              const el = bodyRef.current;\n              const useInner = !!el && (el.scrollHeight > el.clientHeight + 1);\n              const target = prevSt + headH;\n              if (useInner && el) {\n                // важно: не даём улететь в 0 при \"схлопывании\" шапки\n                if ((el.scrollTop || 0) < 2) el.scrollTop = target;\n              } else {\n                const y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n                if (y < 2) { try { window.scrollTo(0, target); } catch {} }\n              }\n            } catch {}\n          };\n          try { requestAnimationFrame(() => requestAnimationFrame(applyComp)); } catch { try { setTimeout(applyComp, 0); } catch {} }\n        }\n       }\n\n      lastTop = st;\n    });\n  };\n\n  const el = bodyRef.current;\n  const opts = { passive: true };\n\n  // слушаем и body (если скролл внутри), и window (если скролл на странице)\n  try { el?.addEventListener?.('scroll', onScroll, opts); } catch {}\n  window.addEventListener('scroll', onScroll, opts);\n\n  // initial sync\n  onScroll();\n\n  return () => {\n    try { el?.removeEventListener?.('scroll', onScroll); } catch {}\n    window.removeEventListener('scroll', onScroll);\n    if (raf) { try { window.cancelAnimationFrame(raf) } catch {} raf = 0; }\n  };\n}, [sel?.id]);",
          "add": 1,
          "rem": 1,
          "si": 0,
          "ci": 0,
          "raf": 3,
          "caf": 1,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(3) > cancelAnimationFrame(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\components\\SnowFX.jsx",
      "issues": [
        {
          "startLine": 208,
          "endLine": 314,
          "block": "  useEffect(() => {\n    if (typeof window === 'undefined') return\n    if (!flakesRef.current.length) return\n\n    lastScrollYRef.current = window.scrollY || 0\n    lastTimeRef.current = 0\n\n    let stopped = false\n\n    const loop = (ts) => {\n      if (stopped) return\n\n      const { w, h } = worldRef.current\n      if (!w || !h) initWorld()\n\n      if (!lastTimeRef.current) {\n        lastTimeRef.current = ts\n      }\n\n      const dtMs = ts - lastTimeRef.current\n      lastTimeRef.current = ts\n      const dt = Math.min(0.05, Math.max(0.012, dtMs / 1000))\n\n      const flakes = flakesRef.current\n      if (!flakes.length) {\n        // если компонент уже размонтирован (cleanup выставил stopped),\n        // не планируем следующий кадр — иначе можно оставить \"висящий\" RAF\n        if (!stopped) animFrameRef.current = requestAnimationFrame(loop)\n        return\n      }\n\n      const bottom = h + 40\n      const left = -40\n      const right = w + 40\n\n      // плавное затухание импульса (0..1)\n      const now = ts\n      const impulseLeft = Math.max(0, impulseUntilRef.current - now)\n      const impulsePhase = Math.min(1, impulseLeft / IMPULSE_DURATION_MS)\n      const targetStrength = impulsePhase\n      const currentStrength = impulseStrengthRef.current\n      // сглаженный переход к нужной силе\n      impulseStrengthRef.current = currentStrength + (targetStrength - currentStrength) * 0.18\n\n      const impulseK = impulseStrengthRef.current\n\n      const tNow = nowMs()\n\n      for (let i = 0; i < flakes.length; i += 1) {\n        const f = flakes[i]\n        const depthFactor = 0.4 + f.depth * 0.6\n\n        // базовая гравитация\n        f.vy += GRAVITY * depthFactor * dt\n\n        // лёгкий боковой шум\n        f.vx += (Math.random() * 2 - 1) * WIND_NOISE * dt * depthFactor\n\n        // подавляем «бешенство» скоростей\n        f.vx *= FRICTION_VX\n        f.vy *= FRICTION_VY\n\n        // плавный возврат к базовой скорости падения\n        // чем меньше impulseK, тем сильнее возвращаем к baseVy\n        const relax = impulseK > 0.01 ? IMPULSE_DAMPING : 0.9\n        f.vy = f.vy * relax + f.baseVy * (1 - relax)\n\n        // обновляем позицию\n        f.x += f.vx * dt\n        f.y += f.vy * dt\n\n        // лёгкое покачивание\n        f.swayPhase += f.swaySpeed * dt\n\n        // вращение вокруг своей оси\n        f.angle += f.spinDir * f.spinSpeed * dt\n        if (f.angle > 360) f.angle -= 360\n        if (f.angle < 0) f.angle += 360\n\n        // ушли за границы — респавним сверху, НО не чаще кулдауна\n        if (f.y > bottom || f.x < left || f.x > right) {\n          if (tNow >= (f.nextRespawnAt || 0)) {\n            respawnFlake(f, true)\n          } else {\n            // держим за границей, чтобы не “дёргалось” у нижней границы\n            f.y = bottom + 10\n          }\n        }\n      }\n\n      setTick((x0) => x0 + 1)\n\n      // если компонент уже размонтирован (cleanup выставил stopped),\n      // не планируем следующий кадр\n      if (!stopped) animFrameRef.current = requestAnimationFrame(loop)\n    }\n\n    animFrameRef.current = requestAnimationFrame(loop)\n\n    return () => {\n      stopped = true\n      const rafId = animFrameRef.current\n      animFrameRef.current = null\n      if (rafId) cancelAnimationFrame(rafId)\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])",
          "add": 0,
          "rem": 0,
          "si": 0,
          "ci": 0,
          "raf": 3,
          "caf": 1,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(3) > cancelAnimationFrame(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\app\\exchange\\page.js",
      "issues": [
        {
          "startLine": 1570,
          "endLine": 1587,
          "block": "  useEffect(() => {\n    if (!Number.isFinite(limit)) return\n    const id = setInterval(() => {\n      if (document.visibilityState !== 'visible') return\n      flushQuota()\n    }, STATUS_REFRESH_MS)\n\n    const onHide = () => { flushQuota() }\n    window.addEventListener('pagehide', onHide)\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') onHide()\n    })\n\n    return () => {\n      clearInterval(id)\n      window.removeEventListener('pagehide', onHide)\n    }\n  }, [limit, flushQuota])",
          "add": 2,
          "rem": 1,
          "si": 1,
          "ci": 1,
          "raf": 0,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ addEventListener(2) > removeEventListener(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\components\\QCoinDropFX.jsx",
      "issues": [
        {
          "startLine": 134,
          "endLine": 254,
          "block": "  useEffect(() => {\n    if (!isBrowser()) return\n    if (motionReducedRef.current) return\n\n    lastTimeRef.current = 0\n    let stopped = false\n\n    const loop = (ts) => {\n      if (stopped) return\n\n      const { w, h } = worldRef.current\n      if (!w || !h) initWorld()\n\n      if (!lastTimeRef.current) {\n        lastTimeRef.current = ts\n      }\n\n      const dtMs = ts - lastTimeRef.current\n      lastTimeRef.current = ts\n      const dt = Math.min(0.05, Math.max(0.012, dtMs / 1000))\n\n      // плавное затухание импульсов ветра\n      const now = ts\n      const impulseLeft = Math.max(0, impulseUntilRef.current - now)\n      const impulsePhase = Math.min(1, impulseLeft / IMPULSE_DURATION_MS)\n      const targetStrength = impulsePhase\n      const currentStrength = impulseStrengthRef.current\n      impulseStrengthRef.current =\n        currentStrength + (targetStrength - currentStrength) * 0.18\n      const impulseK = impulseStrengthRef.current\n\n      let coin = coinRef.current\n\n      // спавним монету раз в intervalMs, только для авторизованных\n      if (uid && !coin) {\n        const nextAt = spawnAtRef.current || 0\n        if (!nextAt || ts >= nextAt) {\n          const depth = 0.4 + Math.random() * 0.6\n          const size = minSize + depth * (maxSize - minSize)\n          const baseVy = 60 + 50 * depth\n\n          // === РАНДОМНЫЙ МНОЖИТЕЛЬ ДЛЯ ЭТОЙ МОНЕТЫ ===\n          const mult = COIN_MULTIPLIERS[(Math.random() * COIN_MULTIPLIERS.length) | 0]\n\n          coin = {\n            id: ts,\n            depth,\n            size,\n            x: Math.random() * w,\n            y: -size,\n            vx: (Math.random() * 2 - 1) * (10 + 20 * depth),\n            vy: baseVy,\n            baseVy,\n            swayPhase: Math.random() * Math.PI * 2,\n            swaySpeed: 0.4 + Math.random() * 1.2,\n            swayAmp: 8 + 18 * depth,\n            angle: Math.random() * 360,\n            spinDir: Math.random() < 0.5 ? -1 : 1,\n            spinSpeed: 30 + Math.random() * 50,\n            opacity: 0.98,\n            exploding: false,\n\n            // множитель награды этой монеты\n            mult,\n          }\n\n          coinRef.current = coin\n          // следующая монета — ещё через intervalMs\n          spawnAtRef.current = ts + intervalMs\n        }\n      }\n\n      if (coin) {\n        const f = coin\n        const depthFactor = 0.5 + f.depth * 0.7\n\n        // гравитация + лёгкий боковой шум\n        f.vy += GRAVITY * depthFactor * dt\n        f.vx += (Math.random() * 2 - 1) * WIND_NOISE * dt * depthFactor\n\n        f.vx *= FRICTION_VX\n        f.vy *= FRICTION_VY\n\n        // возврат к базовой скорости падения\n        const relax = impulseK > 0.01 ? IMPULSE_DAMPING : 0.9\n        f.vy = f.vy * relax + f.baseVy * (1 - relax)\n\n        // позиции\n        f.x += f.vx * dt\n        f.y += f.vy * dt\n\n        // sway + spin\n        f.swayPhase += f.swaySpeed * dt\n        f.angle += f.spinDir * f.spinSpeed * dt\n        if (f.angle > 360) f.angle -= 360\n        if (f.angle < 0) f.angle += 360\n\n        const bottom = h + 80\n        const left = -80\n        const right = w + 80\n        if (f.y > bottom || f.x < left || f.x > right) {\n          coinRef.current = null\n        }\n      }\n\n      setTick((x) => (x + 1) & 1023)\n\n      // ВАЖНО: если компонент уже размонтирован (cleanup выставил stopped),\n      // не планируем следующий кадр, чтобы не оставлять \"висящий\" RAF.\n      if (!stopped) animFrameRef.current = requestAnimationFrame(loop)\n    }\n\n    animFrameRef.current = requestAnimationFrame(loop)\n\n    return () => {\n      stopped = true\n      const rafId = animFrameRef.current\n      animFrameRef.current = null\n      if (rafId) cancelAnimationFrame(rafId)\n    }\n  }, [uid, intervalMs, minSize, maxSize, initWorld])",
          "add": 0,
          "rem": 0,
          "si": 0,
          "ci": 0,
          "raf": 2,
          "caf": 1,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(2) > cancelAnimationFrame(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\components\\BgAudio.js",
      "issues": [
        {
          "startLine": 73,
          "endLine": 122,
          "block": "  useEffect(() => {\n    const a = audioRef.current\n    if (!a || !locked) return\n\n    let removed = false\n\n    const enableSound = async () => {\n      if (!audioRef.current) return\n      try {\n        audioRef.current.muted = false\n        await audioRef.current.play()\n        setPlaying(true)\n        setLocked(false)\n\n        window.dispatchEvent(\n          new CustomEvent('site-media-play', {\n            detail: { source: 'bg-audio' },\n          })\n        )\n\n        detach()\n      } catch {}\n    }\n\n    const onGesture = () => enableSound()\n\n    function attach() {\n      if (removed) return\n      window.addEventListener('pointerdown', onGesture, true)\n      window.addEventListener('click', onGesture, true)\n      window.addEventListener('keydown', onGesture, true)\n      window.addEventListener('wheel', onGesture, { passive: true, capture: true })\n      window.addEventListener('touchstart', onGesture, { passive: true, capture: true })\n      window.addEventListener('touchmove', onGesture, { passive: true, capture: true })\n    }\n\n    function detach() {\n      if (removed) return\n      removed = true\n      window.removeEventListener('pointerdown', onGesture, true)\n      window.removeEventListener('click', onGesture, true)\n      window.removeEventListener('keydown', onGesture, true)\n      window.removeEventListener('wheel', onGesture, true)\n      window.removeEventListener('touchstart', onGesture, true)\n      window.removeEventListener('touchmove', onGesture, true)\n    }\n\n    attach()\n    return detach\n  }, [locked])",
          "add": 6,
          "rem": 6,
          "si": 0,
          "ci": 0,
          "raf": 0,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ нет cleanup return(), но есть подписки/таймеры"
          ]
        }
      ]
    }
  ]
}