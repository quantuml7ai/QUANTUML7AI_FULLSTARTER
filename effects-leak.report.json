{
  "root": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter",
  "generatedAt": "2026-02-09T13:28:03.562Z",
  "all": [
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\app\\forum\\Forum.jsx",
      "issues": [
        {
          "startLine": 10555,
          "endLine": 10626,
          "block": "  React.useEffect(() => {\n    if (!active || typeof window === 'undefined') return;\n\n    const { body, documentElement } = document;\n\n    // В форуме основной скролл живёт во внутреннем контейнере .body (overflowY:auto).\n    // Если он есть — лочим именно его, чтобы после закрытия оверлея НЕ прыгать в самый верх.\n    const scrollEl =\n      document.querySelector('[data-forum-scroll=\"1\"]') ||\n      document.querySelector('.forum_root .grid2 > section > .body') ||\n      null;\n\n    const winY = window.scrollY || window.pageYOffset || 0;\n    const innerY = scrollEl ? (scrollEl.scrollTop || 0) : 0;\n\n    const useInner =\n      !!scrollEl &&\n      scrollEl !== body &&\n      (scrollEl.scrollHeight - scrollEl.clientHeight) > 2;\n\n    const prev = {\n      bodyOverflow: body.style.overflow,\n      bodyPosition: body.style.position,\n      bodyTop: body.style.top,\n      bodyWidth: body.style.width,\n      htmlOverscroll: documentElement.style.overscrollBehaviorY,\n      innerOverflow: useInner ? scrollEl.style.overflow : null,\n      innerOverscroll: useInner ? scrollEl.style.overscrollBehaviorY : null,\n    };\n\n    if (useInner) {\n      // Лочим внутренний скролл-контейнер без body:fixed (иначе возможны прыжки).\n      body.style.overflow = 'hidden';\n      documentElement.style.overscrollBehaviorY = 'none';\n      scrollEl.style.overflow = 'hidden';\n      scrollEl.style.overscrollBehaviorY = 'none';\n    } else {\n      // Фолбэк: обычная страница со скроллом окна.\n      body.style.position = 'fixed';\n      body.style.top = `-${winY}px`;\n      body.style.width = '100%';\n      body.style.overflow = 'hidden';\n      documentElement.style.overscrollBehaviorY = 'none';\n    }\n\n    const prevent = (e) => e.preventDefault();\n    window.addEventListener('wheel', prevent, { passive: false });\n    window.addEventListener('touchmove', prevent, { passive: false });\n\n    return () => {\n      window.removeEventListener('wheel', prevent);\n      window.removeEventListener('touchmove', prevent);\n\n      body.style.overflow = prev.bodyOverflow;\n      body.style.position = prev.bodyPosition;\n      body.style.top = prev.bodyTop;\n      body.style.width = prev.bodyWidth;\n      documentElement.style.overscrollBehaviorY = prev.htmlOverscroll;\n\n      if (useInner && scrollEl) {\n        scrollEl.style.overflow = prev.innerOverflow || '';\n        scrollEl.style.overscrollBehaviorY = prev.innerOverscroll || '';\n        requestAnimationFrame(() => {\n          try { scrollEl.scrollTop = innerY; } catch {}\n        });\n      } else {\n        requestAnimationFrame(() => {\n          try { window.scrollTo(0, winY); } catch {}\n        });\n      }\n    };\n  }, [active]);",
          "add": 2,
          "rem": 2,
          "si": 0,
          "ci": 0,
          "raf": 2,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(2) > cancelAnimationFrame(0)"
          ]
        },
        {
          "startLine": 12339,
          "endLine": 12387,
          "block": "React.useEffect(() => {\n  const onEdit = (e) => {\n    try {\n      const d = e?.detail || {};\n      if (!d?.postId || typeof d?.text !== 'string') return;\n\n      // какой пост правим + текст в композер\n      setEditPostId(String(d.postId));\n      setText(String(d.text));\n\n      // сразу открыть композер\n      try {\n        setComposerActive(true);\n      } catch {}\n\n      // после рендера — проскроллить и фокуснуть поле\n      try {\n        requestAnimationFrame(() => {\n          const root =\n            (composerRef && composerRef.current) ||\n            document.getElementById('forum-composer');\n\n          if (root && root.scrollIntoView) {\n            root.scrollIntoView({ behavior: 'smooth', block: 'center' });\n          }\n\n          // ищем textarea: либо по классу .taInput, либо любую textarea внутри\n          const ta =\n            root?.querySelector?.('.taInput') ||\n            root?.querySelector?.('textarea');\n\n          if (ta && typeof ta.focus === 'function') {\n            ta.focus();\n          }\n        });\n      } catch {}\n\n      // тост про режим редактирования\n      try {\n        toast?.ok?.(t?.('forum_edit_mode'));\n      } catch {}\n    } catch {}\n  };\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('forum:edit', onEdit);\n    return () => window.removeEventListener('forum:edit', onEdit);\n  }\n}, [t, toast]); // ВАЖНО: без setComposerActive и composerRef",
          "add": 1,
          "rem": 1,
          "si": 0,
          "ci": 0,
          "raf": 1,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(1) > cancelAnimationFrame(0)"
          ]
        },
        {
          "startLine": 13423,
          "endLine": 13579,
          "block": "useEffect(() => {\n  if (!isBrowser()) return;\n\n  // === HEAD AUTO OPEN/CLOSE: пороги + гистерезис + анти-дергание scrollTop ===\n  // CSS-переменные (px):\n  //  --head-open-threshold-desktop: 870px;\n  //  --head-close-threshold-desktop: 920px;  // обычно open + 40..120\n  //  --head-open-threshold-mobile: 550px;\n  //  --head-close-threshold-mobile: 610px;   // обычно open + 40..120\n  //\n  // Плюс: --head-collapse-scroll-compensate: 1;  (0/1) — компенсировать скролл при скрытии шапки\n\n  const DEFAULT_HEAD_OPEN_DESKTOP = 870;\n  const DEFAULT_HEAD_CLOSE_DESKTOP = 920;\n  const DEFAULT_HEAD_OPEN_MOBILE = 550;\n  const DEFAULT_HEAD_CLOSE_MOBILE = 610;\n\n  const isMobileUi = () => {\n    try {\n      const coarse = !!window?.matchMedia?.('(pointer: coarse)')?.matches;\n      const narrow = (Number(window?.innerWidth || 0) || 0) <= 720;\n      return coarse || narrow;   \n     } catch {}\n    return false;\n  };\n\n  const readCssPx = (varName, fallback) => {\n    try {\n      const raw = window.getComputedStyle(document.documentElement).getPropertyValue(varName);\n      const v = String(raw || '').trim();\n      const n = parseFloat(v);\n      return Number.isFinite(n) ? n : fallback;\n    } catch {}\n    return fallback;\n  };\n\n  const readCssFlag01 = (varName, fallback01) => {\n    try {\n      const raw = window.getComputedStyle(document.documentElement).getPropertyValue(varName);\n      const v = String(raw || '').trim();\n      if (v === '0') return 0;\n      if (v === '1') return 1;\n      const n = parseFloat(v);\n      return Number.isFinite(n) ? (n ? 1 : 0) : fallback01;\n    } catch {}\n    return fallback01;\n  };\n\n  const getHeadOpenAt = () => {\n    const m = isMobileUi();\n    return readCssPx(m ? '--head-open-threshold-mobile' : '--head-open-threshold-desktop',\n      m ? DEFAULT_HEAD_OPEN_MOBILE : DEFAULT_HEAD_OPEN_DESKTOP\n    );\n  };\n\n  const getHeadCloseAt = (openAt) => {\n    const m = isMobileUi();\n    const closeAt = readCssPx(m ? '--head-close-threshold-mobile' : '--head-close-threshold-desktop',\n      m ? DEFAULT_HEAD_CLOSE_MOBILE : DEFAULT_HEAD_CLOSE_DESKTOP\n    );\n    // гарантируем гистерезис: close > open хотя бы на 1px\n    return Math.max((Number(openAt) || 0) + 1, Number(closeAt) || 0);\n  };\n\n  const getHeadHeight = () => {\n    try {\n      // headInner — реальная шапка внутри контейнера .head\n      const el = document.querySelector('.headInner') || document.querySelector('.head');\n      const h = el?.getBoundingClientRect?.()?.height;\n      return Number.isFinite(h) ? h : 0;\n    } catch {}\n    return 0;\n  };\n\n  const getScrollTop = () => {\n    const el = bodyRef.current;\n    if (el && el.scrollHeight > el.clientHeight + 1) return el.scrollTop || 0;\n    return (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);\n  };\n\n  let raf = 0;\n  let lastTop = getScrollTop();\n  const onScroll = () => {\n    if (navRestoringRef.current) return;\n    if (raf) return;\n    raf = window.requestAnimationFrame(() => {\n      raf = 0;\n      const st = getScrollTop();\n      const delta = st - lastTop;\n      const scrollingDown = delta > 0;\n      const openAt = getHeadOpenAt();\n      const closeAt = getHeadCloseAt(openAt);\n      const atTopForOpen = st <= openAt;\n\n      // если шапка закреплена вручную — ничего не трогаем\n      if (headPinnedRef.current) {\n        headAutoOpenRef.current = false;\n        lastTop = st;\n        return;\n      }\n\n      // Как только упираемся в верх — сразу открываем шапку\n      if (!videoFeedOpenRef.current && atTopForOpen) {\n        if (headHiddenRef.current) {\n          setHeadPinned(false);\n          setHeadHidden(false);\n        }\n        headAutoOpenRef.current = false;\n      } else if (!headHiddenRef.current && scrollingDown && st > closeAt) {\n        // Скрываем только ниже closeAt (гистерезис), чтобы не дергалось на пороге.\n        // И компенсируем скролл, чтобы при скрытии шапки scrollTop не \"клампился\" в 0.\n        const prevSt = st;\n        const headH = getHeadHeight();\n        const compensate = readCssFlag01('--head-collapse-scroll-compensate', 1);\n        setHeadPinned(false);\n        setHeadHidden(true);\n\n        if (compensate && headH > 1) {\n          // Двойной RAF — ждём, пока DOM применит collapsed-класс и пересчитает layout.\n          const applyComp = () => {\n            try {\n              const el = bodyRef.current;\n              const useInner = !!el && (el.scrollHeight > el.clientHeight + 1);\n              const target = prevSt + headH;\n              if (useInner && el) {\n                // важно: не даём улететь в 0 при \"схлопывании\" шапки\n                if ((el.scrollTop || 0) < 2) el.scrollTop = target;\n              } else {\n                const y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n                if (y < 2) { try { window.scrollTo(0, target); } catch {} }\n              }\n            } catch {}\n          };\n          try { requestAnimationFrame(() => requestAnimationFrame(applyComp)); } catch { try { setTimeout(applyComp, 0); } catch {} }\n        }\n       }\n\n      lastTop = st;\n    });\n  };\n\n  const el = bodyRef.current;\n  const opts = { passive: true };\n\n  // слушаем и body (если скролл внутри), и window (если скролл на странице)\n  try { el?.addEventListener?.('scroll', onScroll, opts); } catch {}\n  window.addEventListener('scroll', onScroll, opts);\n\n  // initial sync\n  onScroll();\n\n  return () => {\n    try { el?.removeEventListener?.('scroll', onScroll); } catch {}\n    window.removeEventListener('scroll', onScroll);\n    if (raf) { try { window.cancelAnimationFrame(raf) } catch {} raf = 0; }\n  };\n}, [sel?.id]);",
          "add": 1,
          "rem": 1,
          "si": 0,
          "ci": 0,
          "raf": 3,
          "caf": 1,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(3) > cancelAnimationFrame(1)"
          ]
        },
        {
          "startLine": 13583,
          "endLine": 13829,
          "block": "useEffect(() => {\n  if (!isBrowser()) return;\n  // ⚠️ В треде темы (ветка сообщений) sticky-feed ломает тач-скролл:\n  // он гасит нативный скролл (touchAction:none + preventDefault), а \"ручной\" scrollTop\n  // может крутить не тот контейнер. Поэтому включаем sticky-feed только в режиме ленты.\n  if (sel?.id) return;\n \n  // ✅ Новый sticky-feed: ТОЛЬКО TAЧ, строго 1 свайп = 1 карточка, без центрирования и без wheel.\n  // Работает на iOS/Android/планшетах/тач-ноутах.\n\n  let attachedEl = null;\n  const optsTouch = { passive: false, capture: true }; // iOS: только так preventDefault реально гасит momentum\n\n  const isTouchDevice = () => {\n    try {\n      const coarse = !!window?.matchMedia?.('(pointer: coarse)')?.matches;\n      const mtp = Number(navigator?.maxTouchPoints || 0) > 0;\n      return coarse || mtp;\n    } catch {}\n    return false;\n  };\n\n  const isInIgnoredUi = (target) => {\n    try {\n      const el = target?.nodeType ? target : null;\n      if (!el?.closest) return false;\n      if (el.closest('.searchDrop')) return true;\n      if (el.closest('.emojiPanel')) return true;\n      // не ломаем поля ввода/кнопки/ползунки\n      if (el.closest('input, textarea, select, button, a')) return true;\n      if (el.closest('input[type=\"range\"]')) return true;\n    } catch {}\n    return false;\n  };\n\n  // ВАЖНО: реальный скролл-контейнер форума — это bodyRef / data-forum-scroll=\"1\"\n  const getScrollEl = () => {\n    try {\n      return bodyRef?.current || document.querySelector('[data-forum-scroll=\"1\"]') || null;\n    } catch {}\n    return null;\n  };\n\n  const getCards = (scrollEl) => {\n    try {\n      const nodes = scrollEl?.querySelectorAll?.('[data-feed-card=\"1\"]') || [];\n      return Array.from(nodes).filter(Boolean);\n    } catch {}\n    return [];\n  };\n\n  const readTopOffset = () => {\n    // если сверху есть sticky панели — чтобы карточка не уходила под них\n    try {\n      const raw = window.getComputedStyle(document.documentElement).getPropertyValue('--feed-snap-top-offset');\n      const v = String(raw || '').trim();\n      const n = parseFloat(v);\n      return Number.isFinite(n) ? n : 0;\n    } catch {}\n    return 0;\n  };\n\n  const clampScrollTop = (scrollEl, top) => {\n    try {\n      const maxTop = Math.max(0, (scrollEl.scrollHeight || 0) - (scrollEl.clientHeight || 0));\n      return Math.max(0, Math.min(Number(top) || 0, maxTop));\n    } catch {}\n    return Math.max(0, Number(top) || 0);\n  };\n\n  const findTopIndex = (cards, scrollEl) => {\n    if (!cards.length || !scrollEl) return 0;\n    try {\n      const contRect = scrollEl.getBoundingClientRect();\n      const topY = contRect.top + readTopOffset();\n      let best = 0;\n      let bestDist = Infinity;\n      for (let i = 0; i < cards.length; i++) {\n        const r = cards[i].getBoundingClientRect();\n        const d = Math.abs(r.top - topY);\n        if (d < bestDist) { bestDist = d; best = i; }\n      }\n      return best;\n    } catch {}\n    return 0;\n  };\n\n  const scrollCardToTop = (scrollEl, card) => {\n    if (!scrollEl || !card) return;\n    try {\n      const contRect = scrollEl.getBoundingClientRect();\n      const r = card.getBoundingClientRect();\n      const topOffset = readTopOffset();\n      const delta = (r.top - contRect.top) - topOffset;\n      const nextTop = clampScrollTop(scrollEl, (scrollEl.scrollTop || 0) + delta);\n      scrollEl.scrollTop = nextTop; // auto: мгновенно, чтобы не было инерции/улёта\n    } catch {}\n  };\n\n  const restoreScrollStyles = (st) => {\n    try {\n      const el = st?.scrollEl;\n      if (!el) return;\n      el.style.webkitOverflowScrolling = st.prevWos || '';\n      el.style.overscrollBehavior = st.prevOb || '';\n      el.style.touchAction = st.prevTa || '';\n    } catch {}\n  };\n\n  const onTouchStart = (e) => {\n    try {\n      if (!isTouchDevice()) return;\n      if (!e?.touches || e.touches.length !== 1) return;\n      if (isInIgnoredUi(e.target)) return;\n\n      const scrollEl = getScrollEl();\n      if (!scrollEl) return;\n\n      const cards = getCards(scrollEl);\n      if (cards.length < 2) return; // если карточек нет — не вмешиваемся\n\n      // iOS/Android: гасим overscroll/momentum на время жеста\n      const prevWos = scrollEl.style.webkitOverflowScrolling;\n      const prevOb = scrollEl.style.overscrollBehavior;\n      const prevTa = scrollEl.style.touchAction;\n      scrollEl.style.webkitOverflowScrolling = 'auto';\n      scrollEl.style.overscrollBehavior = 'contain';\n      scrollEl.style.touchAction = 'none';\n\n      const t0 = e.touches[0];\n      stickyFeedTouchRef.current = {\n        active: true,\n        startY: t0.clientY,        \n        startX: t0.clientX,\n        startTop: Number(scrollEl.scrollTop || 0),\n        locked: false,\n        scrollEl,\n        prevWos,\n        prevOb,\n        prevTa,\n      };\n    } catch {}\n  };\n\n  const onTouchMove = (e) => {\n    try {\n      const st = stickyFeedTouchRef.current;\n      if (!st?.active) return;\n      if (!isTouchDevice()) return;\n      if (!e?.touches || e.touches.length !== 1) return;\n      if (isInIgnoredUi(e.target)) return;\n\n      const scrollEl = st.scrollEl;\n      if (!scrollEl) return;\n\n      const t = e.touches[0];\n      const dy = t.clientY - (st.startY || 0);\n      const dx = t.clientX - (st.startX || 0);\n\n      // Берём только вертикальный жест\n      if (Math.abs(dy) > 6 && Math.abs(dy) > Math.abs(dx)) {\n        st.locked = true;\n        // полностью выключаем нативный скролл (иначе momentum улетит)\n        try { e.preventDefault(); } catch {}\n        // ведём контейнер вручную, чтобы было ощущение \"тащу ленту\"\n        scrollEl.scrollTop = clampScrollTop(scrollEl, (st.startTop || 0) - dy);\n      }\n    } catch {}\n  };\n\n  const onTouchEnd = (e) => {\n    try {\n      const st = stickyFeedTouchRef.current;\n      if (!st?.active) return;\n      st.active = false;\n\n      const scrollEl = st.scrollEl;\n      // восстановить стили нужно ВСЕГДА\n      restoreScrollStyles(st);\n\n      if (!isTouchDevice()) return;\n      if (isInIgnoredUi(e.target)) return;\n      if (!st.locked) return; // не вертикальный свайп — не мешаем\n      if (!scrollEl) return;\n\n      const cards = getCards(scrollEl);\n      if (cards.length < 2) return;\n\n      const changed = e?.changedTouches && e.changedTouches[0];\n      if (!changed) return;\n      const dy = changed.clientY - (st.startY || 0);\n      const dx = changed.clientX - (st.startX || 0);\n      if (Math.abs(dy) < 30 || Math.abs(dy) < Math.abs(dx)) {\n        // слабый жест → просто снап на ближайшую текущую\n        const idx0 = findTopIndex(cards, scrollEl);\n        scrollCardToTop(scrollEl, cards[idx0]);\n        return;\n      }\n\n      const nowTs = Date.now();\n      if ((stickyFeedLockRef.current?.until || 0) > nowTs) return;\n      stickyFeedLockRef.current = { until: nowTs + 320 };\n\n      const dir = dy < 0 ? 1 : -1; // swipe up => next\n      const idx = findTopIndex(cards, scrollEl);\n      const next = Math.max(0, Math.min(cards.length - 1, idx + dir));\n      scrollCardToTop(scrollEl, cards[next]); // ✅ строго одна карточка\n    } catch {\n      // на всякий случай восстановим стили даже при ошибке\n      try { restoreScrollStyles(stickyFeedTouchRef.current); } catch {}\n    }\n  };\n\n  const attach = () => {\n    const scrollEl = getScrollEl();\n    if (!scrollEl) return;\n    if (attachedEl === scrollEl) return;\n    if (attachedEl) {\n      try { attachedEl.removeEventListener('touchstart', onTouchStart, optsTouch); } catch {}\n      try { attachedEl.removeEventListener('touchmove', onTouchMove, optsTouch); } catch {}\n      try { attachedEl.removeEventListener('touchend', onTouchEnd, optsTouch); } catch {}\n    }\n    attachedEl = scrollEl;\n    try { scrollEl.addEventListener('touchstart', onTouchStart, optsTouch); } catch {}\n    try { scrollEl.addEventListener('touchmove', onTouchMove, optsTouch); } catch {}\n    try { scrollEl.addEventListener('touchend', onTouchEnd, optsTouch); } catch {}\n  };\n\n  attach();\n\n  // если bodyRef появится чуть позже — подхватим\n  const t = setInterval(attach, 700);\n\n  return () => {\n    try { clearInterval(t); } catch {}\n    // ✅ Если эффект снимается при переходе (например, открыли тред),\n    // обязательно откатываем стили скролла, иначе touchAction может остаться 'none'.\n    try { restoreScrollStyles(stickyFeedTouchRef.current); } catch {}\n    try { stickyFeedTouchRef.current = { active: false, startY: 0, startX: 0 }; } catch {}\n     if (attachedEl) {\n      try { attachedEl.removeEventListener('touchstart', onTouchStart, optsTouch); } catch {}\n      try { attachedEl.removeEventListener('touchmove', onTouchMove, optsTouch); } catch {}\n      try { attachedEl.removeEventListener('touchend', onTouchEnd, optsTouch); } catch {}\n    }\n    attachedEl = null;\n  };\n}, [sel?.id]);",
          "add": 3,
          "rem": 6,
          "si": 1,
          "ci": 1,
          "raf": 0,
          "caf": 0,
          "rect": 4,
          "flags": [
            "⚠ getBoundingClientRect внутри effect: 4 (часто признак дорогих измерений)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\components\\SnowFX.jsx",
      "issues": [
        {
          "startLine": 208,
          "endLine": 307,
          "block": "  useEffect(() => {\n    if (typeof window === 'undefined') return\n    if (!flakesRef.current.length) return\n\n    lastScrollYRef.current = window.scrollY || 0\n    lastTimeRef.current = 0\n\n    let stopped = false\n\n    const loop = (ts) => {\n      if (stopped) return\n\n      const { w, h } = worldRef.current\n      if (!w || !h) initWorld()\n\n      if (!lastTimeRef.current) {\n        lastTimeRef.current = ts\n      }\n\n      const dtMs = ts - lastTimeRef.current\n      lastTimeRef.current = ts\n      const dt = Math.min(0.05, Math.max(0.012, dtMs / 1000))\n\n      const flakes = flakesRef.current\n      if (!flakes.length) {\n        animFrameRef.current = requestAnimationFrame(loop)\n        return\n      }\n\n      const bottom = h + 40\n      const left = -40\n      const right = w + 40\n\n      // плавное затухание импульса (0..1)\n      const now = ts\n      const impulseLeft = Math.max(0, impulseUntilRef.current - now)\n      const impulsePhase = Math.min(1, impulseLeft / IMPULSE_DURATION_MS)\n      const targetStrength = impulsePhase\n      const currentStrength = impulseStrengthRef.current\n      // сглаженный переход к нужной силе\n      impulseStrengthRef.current = currentStrength + (targetStrength - currentStrength) * 0.18\n\n      const impulseK = impulseStrengthRef.current\n\n      const tNow = nowMs()\n\n      for (let i = 0; i < flakes.length; i += 1) {\n        const f = flakes[i]\n        const depthFactor = 0.4 + f.depth * 0.6\n\n        // базовая гравитация\n        f.vy += GRAVITY * depthFactor * dt\n\n        // лёгкий боковой шум\n        f.vx += (Math.random() * 2 - 1) * WIND_NOISE * dt * depthFactor\n\n        // подавляем «бешенство» скоростей\n        f.vx *= FRICTION_VX\n        f.vy *= FRICTION_VY\n\n        // плавный возврат к базовой скорости падения\n        // чем меньше impulseK, тем сильнее возвращаем к baseVy\n        const relax = impulseK > 0.01 ? IMPULSE_DAMPING : 0.9\n        f.vy = f.vy * relax + f.baseVy * (1 - relax)\n\n        // обновляем позицию\n        f.x += f.vx * dt\n        f.y += f.vy * dt\n\n        // лёгкое покачивание\n        f.swayPhase += f.swaySpeed * dt\n\n        // вращение вокруг своей оси\n        f.angle += f.spinDir * f.spinSpeed * dt\n        if (f.angle > 360) f.angle -= 360\n        if (f.angle < 0) f.angle += 360\n\n        // ушли за границы — респавним сверху, НО не чаще кулдауна\n        if (f.y > bottom || f.x < left || f.x > right) {\n          if (tNow >= (f.nextRespawnAt || 0)) {\n            respawnFlake(f, true)\n          } else {\n            // держим за границей, чтобы не “дёргалось” у нижней границы\n            f.y = bottom + 10\n          }\n        }\n      }\n\n      setTick((x0) => x0 + 1)\n      animFrameRef.current = requestAnimationFrame(loop)\n    }\n\n    animFrameRef.current = requestAnimationFrame(loop)\n\n    return () => {\n      stopped = true\n      if (animFrameRef.current) cancelAnimationFrame(animFrameRef.current)\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])",
          "add": 0,
          "rem": 0,
          "si": 0,
          "ci": 0,
          "raf": 3,
          "caf": 1,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(3) > cancelAnimationFrame(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\app\\exchange\\page.js",
      "issues": [
        {
          "startLine": 1570,
          "endLine": 1587,
          "block": "  useEffect(() => {\n    if (!Number.isFinite(limit)) return\n    const id = setInterval(() => {\n      if (document.visibilityState !== 'visible') return\n      flushQuota()\n    }, STATUS_REFRESH_MS)\n\n    const onHide = () => { flushQuota() }\n    window.addEventListener('pagehide', onHide)\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') onHide()\n    })\n\n    return () => {\n      clearInterval(id)\n      window.removeEventListener('pagehide', onHide)\n    }\n  }, [limit, flushQuota])",
          "add": 2,
          "rem": 1,
          "si": 1,
          "ci": 1,
          "raf": 0,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ addEventListener(2) > removeEventListener(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\components\\QCoinDropFX.jsx",
      "issues": [
        {
          "startLine": 134,
          "endLine": 249,
          "block": "  useEffect(() => {\n    if (!isBrowser()) return\n    if (motionReducedRef.current) return\n\n    lastTimeRef.current = 0\n    let stopped = false\n\n    const loop = (ts) => {\n      if (stopped) return\n\n      const { w, h } = worldRef.current\n      if (!w || !h) initWorld()\n\n      if (!lastTimeRef.current) {\n        lastTimeRef.current = ts\n      }\n\n      const dtMs = ts - lastTimeRef.current\n      lastTimeRef.current = ts\n      const dt = Math.min(0.05, Math.max(0.012, dtMs / 1000))\n\n      // плавное затухание импульсов ветра\n      const now = ts\n      const impulseLeft = Math.max(0, impulseUntilRef.current - now)\n      const impulsePhase = Math.min(1, impulseLeft / IMPULSE_DURATION_MS)\n      const targetStrength = impulsePhase\n      const currentStrength = impulseStrengthRef.current\n      impulseStrengthRef.current =\n        currentStrength + (targetStrength - currentStrength) * 0.18\n      const impulseK = impulseStrengthRef.current\n\n      let coin = coinRef.current\n\n      // спавним монету раз в intervalMs, только для авторизованных\n      if (uid && !coin) {\n        const nextAt = spawnAtRef.current || 0\n        if (!nextAt || ts >= nextAt) {\n          const depth = 0.4 + Math.random() * 0.6\n          const size = minSize + depth * (maxSize - minSize)\n          const baseVy = 60 + 50 * depth\n\n          // === РАНДОМНЫЙ МНОЖИТЕЛЬ ДЛЯ ЭТОЙ МОНЕТЫ ===\n          const mult = COIN_MULTIPLIERS[(Math.random() * COIN_MULTIPLIERS.length) | 0]\n\n          coin = {\n            id: ts,\n            depth,\n            size,\n            x: Math.random() * w,\n            y: -size,\n            vx: (Math.random() * 2 - 1) * (10 + 20 * depth),\n            vy: baseVy,\n            baseVy,\n            swayPhase: Math.random() * Math.PI * 2,\n            swaySpeed: 0.4 + Math.random() * 1.2,\n            swayAmp: 8 + 18 * depth,\n            angle: Math.random() * 360,\n            spinDir: Math.random() < 0.5 ? -1 : 1,\n            spinSpeed: 30 + Math.random() * 50,\n            opacity: 0.98,\n            exploding: false,\n\n            // множитель награды этой монеты\n            mult,\n          }\n\n          coinRef.current = coin\n          // следующая монета — ещё через intervalMs\n          spawnAtRef.current = ts + intervalMs\n        }\n      }\n\n      if (coin) {\n        const f = coin\n        const depthFactor = 0.5 + f.depth * 0.7\n\n        // гравитация + лёгкий боковой шум\n        f.vy += GRAVITY * depthFactor * dt\n        f.vx += (Math.random() * 2 - 1) * WIND_NOISE * dt * depthFactor\n\n        f.vx *= FRICTION_VX\n        f.vy *= FRICTION_VY\n\n        // возврат к базовой скорости падения\n        const relax = impulseK > 0.01 ? IMPULSE_DAMPING : 0.9\n        f.vy = f.vy * relax + f.baseVy * (1 - relax)\n\n        // позиции\n        f.x += f.vx * dt\n        f.y += f.vy * dt\n\n        // sway + spin\n        f.swayPhase += f.swaySpeed * dt\n        f.angle += f.spinDir * f.spinSpeed * dt\n        if (f.angle > 360) f.angle -= 360\n        if (f.angle < 0) f.angle += 360\n\n        const bottom = h + 80\n        const left = -80\n        const right = w + 80\n        if (f.y > bottom || f.x < left || f.x > right) {\n          coinRef.current = null\n        }\n      }\n\n      setTick((x) => (x + 1) & 1023)\n      animFrameRef.current = requestAnimationFrame(loop)\n    }\n\n    animFrameRef.current = requestAnimationFrame(loop)\n\n    return () => {\n      stopped = true\n      if (animFrameRef.current) cancelAnimationFrame(animFrameRef.current)\n    }\n  }, [uid, intervalMs, minSize, maxSize, initWorld])",
          "add": 0,
          "rem": 0,
          "si": 0,
          "ci": 0,
          "raf": 2,
          "caf": 1,
          "rect": 0,
          "flags": [
            "⚠ requestAnimationFrame(2) > cancelAnimationFrame(1)"
          ]
        }
      ]
    },
    {
      "file": "C:\\Users\\BETEP\\OneDrive\\Рабочий стол\\quantuml7ai_fullstarter\\components\\BgAudio.js",
      "issues": [
        {
          "startLine": 73,
          "endLine": 122,
          "block": "  useEffect(() => {\n    const a = audioRef.current\n    if (!a || !locked) return\n\n    let removed = false\n\n    const enableSound = async () => {\n      if (!audioRef.current) return\n      try {\n        audioRef.current.muted = false\n        await audioRef.current.play()\n        setPlaying(true)\n        setLocked(false)\n\n        window.dispatchEvent(\n          new CustomEvent('site-media-play', {\n            detail: { source: 'bg-audio' },\n          })\n        )\n\n        detach()\n      } catch {}\n    }\n\n    const onGesture = () => enableSound()\n\n    function attach() {\n      if (removed) return\n      window.addEventListener('pointerdown', onGesture, true)\n      window.addEventListener('click', onGesture, true)\n      window.addEventListener('keydown', onGesture, true)\n      window.addEventListener('wheel', onGesture, { passive: true, capture: true })\n      window.addEventListener('touchstart', onGesture, { passive: true, capture: true })\n      window.addEventListener('touchmove', onGesture, { passive: true, capture: true })\n    }\n\n    function detach() {\n      if (removed) return\n      removed = true\n      window.removeEventListener('pointerdown', onGesture, true)\n      window.removeEventListener('click', onGesture, true)\n      window.removeEventListener('keydown', onGesture, true)\n      window.removeEventListener('wheel', onGesture, true)\n      window.removeEventListener('touchstart', onGesture, true)\n      window.removeEventListener('touchmove', onGesture, true)\n    }\n\n    attach()\n    return detach\n  }, [locked])",
          "add": 6,
          "rem": 6,
          "si": 0,
          "ci": 0,
          "raf": 0,
          "caf": 0,
          "rect": 0,
          "flags": [
            "⚠ нет cleanup return(), но есть подписки/таймеры"
          ]
        }
      ]
    }
  ]
}